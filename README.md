Документація проекту системи замовлень

Зміст

Вступ

Огляд проекту

Структура проекту

Використані патерни проектування

Factory Method

Adapter

Observer

Техніки рефакторингу

Заключення

Вступ

Цей проект є системою замовлень, яка демонструє використання різних патернів проектування та технік рефакторингу для підвищення гнучкості, сумісності та масштабованості коду. Проект включає реалізацію трьох основних патернів проектування: Factory Method, Adapter та Observer.

Огляд проекту

Проект створює і керує замовленнями для клієнтів, розраховує загальні суми з урахуванням податків та знижок, і відправляє сповіщення при створенні нових замовлень. Стару систему замовлень було інтегровано з новою через патерн Adapter, що дозволяє використовувати існуючий код без значних змін.

Структура проекту

project/
├── main.py
├── test.py
└── README.md

main.py: Основний модуль, що містить реалізацію всіх класів і патернів проектування.

test.py: Модуль для юніт-тестів, що перевіряють функціональність системи.

README.md: Документація проекту, включаючи опис структури, патернів проектування та технік рефакторингу.

Використані патерни проектування

Factory Method

Призначення:

Factory Method (Фабричний метод) є породжуючим патерном проектування, який надає інтерфейс для створення об'єктів в суперкласі, але дозволяє підкласам змінювати тип створюваних об'єктів. Це забезпечує гнучкість у створенні об'єктів, дозволяючи використовувати загальний інтерфейс для різних реалізацій.

Реалізація:

У проекті використовується клас OrderFactory, який створює об'єкти Order з різними стратегіями знижок. Це дозволяє легко додавати нові типи знижок без зміни існуючого коду.


class OrderFactory:
    @staticmethod
    def create_order(order_id, customer, items, status, discount_strategy_type, discount_value=None):
        if discount_strategy_type == 'no_discount':
            discount_strategy = NoDiscount()
        elif discount_strategy_type == 'percentage_discount':
            discount_strategy = PercentageDiscount(discount_value)
        else:
            raise ValueError("Invalid discount strategy type")
        return Order(order_id, customer, items, status, discount_strategy)
        
Роль в проекті:

Factory Method використовується для створення об'єктів замовлень з різними стратегіями знижок. Це робить код більш гнучким і полегшує додавання нових типів знижок.

Adapter

Призначення:

Adapter (Адаптер) є структурним патерном проектування, який дозволяє об'єктам з несумісними інтерфейсами працювати разом. Він обгортає один з об'єктів, надаючи інтерфейс, сумісний з іншими об'єктами.

Реалізація:

Adapter використовується для інтеграції старої системи замовлень (OldOrderSystem) з новою системою. Клас OrderAdapter реалізує необхідний інтерфейс для сумісності.


class OrderAdapter(OrderInterface):
    def __init__(self, old_order):
        self._old_order = old_order

    def calculate_total(self):
        return self._old_order.total_price()
        
Роль в проекті:

Adapter забезпечує сумісність зі старими замовленнями без зміни їх коду, дозволяючи повторно використовувати існуючий код без значних змін.

Observer

Призначення:

Observer (Спостерігач) є поведінковим патерном проектування, який дозволяє об'єктам підписуватися на події іншого об'єкта та отримувати сповіщення про зміни стану цього об'єкта.

Реалізація:

Observer використовується для відправки сповіщень при додаванні нових замовлень. Клас OrderManagerWithObserver реалізує патерн Observer, а клас EmailNotifier виступає як спостерігач.


class OrderObserver(ABC):
    @abstractmethod
    def update(self, order):
        pass

class EmailNotifier(OrderObserver):
    def update(self, order):
        print(f"Email sent for order {order.order_id} to {order.customer.name}")
        
Роль в проекті:

Observer забезпечує масштабованість системи сповіщень, дозволяючи легко додавати нових спостерігачів без зміни основної логіки.

Техніки рефакторингу

Розбиття на дрібніші класи та методи:

Код було розділено на менші класи та методи для підвищення читабельності та підтримуваності. Наприклад, логіка розрахунку знижок була винесена в окремі стратегії.

Інкапсуляція:

Використання приватних полів та методів для захисту внутрішнього стану об'єктів. Це допомагає зберігати інваріанти класів та уникати побічних ефектів.

Інтерфейси та абстрактні базові класи:

Застосування інтерфейсів та абстрактних базових класів для визначення контрактів, які повинні виконувати реалізуючі класи. Це полегшує розширюваність та забезпечує відповідність принципам SOLID.
